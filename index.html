<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h3>dev</h3>
    <p>master sth</p>
    <!-- <script src="./iterable/each.js"></script> -->
    <!-- <script src="./iterable/this.js"></script> -->
    <!-- <script src="./others/sum.js"></script> -->
    <!-- <script src="./others/binaryTree.js"></script> -->
    <!-- <script src="./others/scheduler.js"></script> -->
    <!-- <script src="./others/chineseToPinyin.js"></script> -->
    <!-- <script src="./arithmetic/objectFlattening.js"></script> -->
    <!-- <script src="./arithmetic/unaryPlus.js"></script> -->
    <!-- <script src="./arithmetic/hashMap.js"></script> -->
    <!-- <script src="./arithmetic/test.js"></script> -->
    <!-- <script src="./others/deepClone.js"></script> -->
    <!-- <script src="./others/binaryTree.js"></script> -->
    <!-- <script src="./others/sort.js"></script> -->
    <!-- <script src="./others/multiRequest.js"></script> -->
    <!-- <script src="./others/nonRepeat.js"></script> -->
    <!-- <script>
        const tree = new BST()
        tree.add(10)
        tree.add(1)
        tree.add(8)
        tree.add(2)
        tree.add(3)
        tree.add(12)
        tree.add(-3)
        tree.print()
    </script> -->
    <script>
        // const p = new Promise((resolve, reject) => {
        //     console.log('step-1')
            // setTimeout(() => {
            //     console.log('step-5')
            /**
             * 即使是同步，then依赖还是会放到事件循环的最后执行
             * 回调是放进宏任务队列 | 微任务队列?
             * 默认: 微任务队列
             * 手动实现：使用setTimeout放入宏任务列队
             * 微任务队列实现：MutationObserver 构造函数
             */
            // reject('error catch')
            // resolve('success cb')
            // }, 800)
        // })

        // console.log('step-2')

        // resolve执行，dispatch后状态变更，modify Subscribers
        // const p0 = p.then('no function') // 不是函数也能让链式继续,会把最近的resolve的值继续往下传递
        // [[PromiseState]]: "fulfilled"
        // [[PromiseResult]]: "success cb"
        // console.log(p0)
        // p0.then(res => {
        //     console.log('p0: ' + res)
        // })
    
        // const p1 = p
        //     .then('not function')
        //     .then(res => {
        //         console.log('step-6')
        //         return {res}
        //     })

        // console.log('step-3')

        // 没有return [[PromiseResult]]: undefined
        // const p2 = p1.then(res => {
        //     console.log('step-7')
        //     console.log(res)
        // })

        // console.log(p2) // rejected

        // const p3 = p2.then(res => {
        //     console.log(res)
        //     throw new Error('sth wrong')
        // })
        // .then(res => {
        //     console.log(res)
        //     return Promise.reject('another thing wrong')
        // })
        // .catch(error => {
        //     console.log(error)
        // })
        // .then(res => {
        //     console.log(res)
        //     return Promise.reject('another thing wrong too')
        // })
        // .catch(error => {
        //     console.log(error)
        // })
        
        // console.log(p3) // fulfilled

        // console.log('step-4')

        // const errorP = p1.then(res => {
        //     throw new Error('error test')
        // })

        // setTimeout(() => {
        //     console.log('i am setTimeout start')
        //     p1.then(res => {
        //         console.log('p1-then')
        //         console.log(res)
        //     })
        //     console.log('i am setTimeout end')
        // })

        // console.log(errorP) // rejected

        // const toP = errorP.catch(error => { // 捕获异常
        //     console.log(error)
        // })

        // console.log(toP) // fulfilled

        // // start ----------------------
        // function getPromise(data = {success: true}, time = 1000) {
        //     return new Promise(resolve => {
        //         setTimeout(() => {
        //             return data
        //         }, time)
        //     })
        // }
        // const func1 = getPromise(1, 1000);
        // const func2 = getPromise(2, 800);
        // const func3 = getPromise(3, 500);
        // [func1, func2, func3]
        //     .reduce((p, f) => p.then(f), Promise.resolve()) // 没有return 上一个的值，大哥?
        //     .then(result3 => {
        //         console.log(result3)
        //     })
        // end -------------------------

    </script>

    <script>
    //     // replace做了什么事？
    //     function format(value) {
    //         value = String(value)
    //         const result = parseInt(value.replace(/[^\d]/g, '').replace(/[-]/g, ''))
    //         console.log(result)
    //         return result
    //     }

    //     format('1a23')

    </script>

    <script>
        // const p = new Promise((resolve, reject) => {
        //     setTimeout(() => {
        //         // reject('error catch')
        //         resolve('success cb')
        //     }, 800)
        // })

        // console.log(p)

        {
            // const p0 = Promise.resolve(p)
            // console.log(p0)
    
            // const p1 = Promise.reject('11')
            // console.log(p1)
    
            // const arr = new Array([1, 2])
    
            // function Arr() {
            //     this.arr = []
            // }
            // Arr.prototype.push = function(item) {
            //     this.arr.push(item)
            // }
    
            // let arrB = new Arr()
            // arrB.push(3)
        }
        
        /*
        * then返回的值的类型-分类处理
        * 1. 本身返回一个新的promise，p_pending的状态去决心这个返回的promise的状态；
        * 
        */
        // const p_pending =  p.then(res => {
        //     return new Promise(resolve => {
        //         setTimeout(() => {
        //             resolve('i tm waiting for 10 sec')
        //         }, 10000)
        //     })
        // })

        // console.log(p_pending)
        
        // new Promise((resolve,reject) => {
        //     console.log('外部promise')
        //     resolve(new Promise((res, rej) => {
        //         setTimeout(() => {
        //             res('settled value was a promise')
        //         }, 1000)
        //     }))
        // })
        //     .then(() => {
        //         console.log('外部第一个then')
        //         // 遇到new会立即执行executor
        //         // 违背了扁平化原则，没有return Promise
        //     //    return new Promise((resolve,reject) => {
        //         new Promise((resolve,reject) => {
        //             console.log('内部promise')
        //             // 这tm怎么说
        //             resolve()
        //         })
        //             .then(() => {
        //             console.log('内部第一个then')
        //             return Promise.resolve()
        //         })
        //             .then(() => {
        //             console.log('内部第二个then')
        //         })
        //         // 没有return,Promise会让链式继续下去
        //     })
        //         .then(() => {
        //         console.log('外部第二个then')
        //     })
        //         .then(() => {
        //         console.log('外部第三个then')
        //     })
        //         .then(() => {
        //         console.log('外部第四个then')
        //     })

        // 输出结果是什么？
        /*
        首次回答：
        
        外部promise
        外部第一个then
        内部promise
        外部第二个then
        外部第三个then
        外部第四个then
        内部第一个then
        内部第二个then

        实际答案：


        外部promise
        index.html:210 外部第一个then
        index.html:213 内部promise
        index.html:217 内部第一个then
        index.html:226 外部第二个then
        index.html:229 外部第三个then
        index.html:232 外部第四个then
        index.html:221 内部第二个then

        */

    </script>
</body>

</html>
